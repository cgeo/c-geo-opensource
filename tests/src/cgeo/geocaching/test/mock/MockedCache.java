package cgeo.geocaching.test.mock;

import cgeo.geocaching.GCConstants;
import cgeo.geocaching.ICache;
import cgeo.geocaching.cgImage;
import cgeo.geocaching.cgTrackable;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.geopoint.GeopointFormatter;
import cgeo.geocaching.utils.BaseUtils;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.List;

public abstract class MockedCache implements ICache {

    final protected Geopoint coords;
    String data;
    String mockedDataUser;

    protected MockedCache(final Geopoint coords) {
        this.coords = coords;
        this.data = MockedCache.readCachePage(getGeocode());
        // for mocked caches the user logged in is the user who saved the html file(s)
        this.mockedDataUser = BaseUtils.getMatch(data, GCConstants.PATTERN_USERLOGGEDIN, true, "");
    }

    public String getMockedDataUser() {
        return mockedDataUser;
    }

    public void setMockedDataUser(String mockedDataUser) {
        this.mockedDataUser = mockedDataUser;
    }

    @SuppressWarnings("static-method")
    public String getDateFormat() {
        return "dd/MM/yyyy";
    }

    /*
     * The data for the caches can be generated by entering the url
     * http://www.geocaching.com/seek/cache_details.aspx?log=y&wp=GCxxxx&numlogs=35&decrypt=y
     * into a browser and saving the file
     */
    public String getData() {
        return this.data;
    }

    public static String readCachePage(final String geocode) {
        try {
            final InputStream is = MockedCache.class.getResourceAsStream("/cgeo/geocaching/test/mock/" + geocode + ".html");
            final BufferedReader br = new BufferedReader(new InputStreamReader(is), 150000);

            final StringBuffer buffer = new StringBuffer();
            String line = null;

            while ((line = br.readLine()) != null) {
                buffer.append(line).append('\n');
            }

            br.close();
            return BaseUtils.replaceWhitespace(buffer.toString());
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    @Override
    public String getLatitude() {
        return coords.format(GeopointFormatter.Format.LAT_DECMINUTE);
    }

    @Override
    public String getLongitude() {
        return coords.format(GeopointFormatter.Format.LON_DECMINUTE);
    }

    @Override
    public boolean isArchived() {
        return false;
    }

    @Override
    public boolean isDisabled() {
        return false;
    }

    @Override
    public boolean isMembersOnly() {
        return false;
    }

    @Override
    public boolean isOwn() {
        return false;
    }

    @Override
    public String getHint() {
        return "";
    }

    @Override
    public String getShortDescription() {
        return "";
    }

    @Override
    public String getPersonalNote() {
        return null;
    }

    @Override
    public boolean isFound() {
        return false;
    }

    @Override
    public boolean isFavorite() {
        return false;
    }

    @Override
    public int getFavoritePoints() {
        return 0;
    }

    @Override
    public boolean isWatchlist() {
        return false;
    }

    @Override
    public List<cgTrackable> getInventory() {
        return null;
    }

    @Override
    public List<cgImage> getSpoilers() {
        return null;
    }

    @Override
    public String getNameForSorting() {
        return getName();
    }

    public Geopoint getCoords() {
        return coords;
    }
}
